WORKING WITH REACT

0. Introduction

React is a JavaScript library for building reusable, component-driven UIs for web pages or applications. It combines HTML with JavaScript functionality into its own markup language called JSX.

* Types of components
- Stateless functional components
    Any function you write which accepts props and returns JSX.

- Stateless component
    Class component that extend React.Component, but does not use internal state

- Stateful component
    Class component that mantains its own internal state. These are commonly referred as components or React components.

1. Creating JSX elements

JSX (J... S... X...) is a syntax extension that allows to write HTML directly within JavaScript.

> You can write JavaScript directly within JSX. To do this, you include the code you want to be treated as JavaScript within curly braces:
    { console.log("this is treated as JavaScript code"); }

> JSX code must be compiled into JavaScript. The transpiler Babel is a popular tool for this process.
> You need to call: ReactDOM.render(JSX, document.getElementById("root")), to place your JSX into React's own lighweight representation of the DOM.

1.1. Simple JSX elements

    const JSX = <h1>Hello JSX!</h1>;
    {/* This is a comment in JSX */}

This stores an h1 element with the text "Hello JSX!" inside the variable JSX.

1.2. Complex JSX elements

A JSX with nested elements inside of it must return a single element, like so:

    const JSX = (
        <div>
            <p>Paragraph One</p>
            <p>Paragraph Two</p>
            <p>Paragraph Three</p>
        </div>
    )

2. Rendering HTML elements to the DOM

JSX is rendered into HTML using React's rendering API known as ReactDOM. It offers a simple method to render React elements to the DOM:

    ReactDOM.render(component_to_render, targetNode)

It must be called after the JSX element declarations.
> The first argument is the React component that you want to render. The second argument is the DOM node that you want to render that component within.
> For JSX elements, you pass in the name of the element that you want to render. For React components, you need to use the HTML-ish custom syntax (<ComponentToRender/>). You use this syntax for both ES6 class components and functional components.

3. Defining an HTML class in JSX

You define a class inside an HTML element in JSX like this:

    <div className="myDiv">Add a class to this div</div>

4. Self -closing JSX tags

Any JSX element can be written with a self closing tag, and every element must be closed:
    HTML            JSX
    <br>   ->       <br/>
    <hr>   ->       <hr/>
    <div></div> ->  <div/>

5. Stateless functional component

Components are the core of React. This is how you create one:

- Using a JavaScript function
This creates a stateless functional component (one that can reveive data and render it, but can't manage or track changes to that data). Here are its requirements:

> The function you write must return either a JSX or null.
> React requires the function name to begin with a capital letter.

    const DemoComponent = () => {
        return (
            <div className="customClass"/>
        );
    };

After being transpiled, the <div> will have a CSS class of customClass.

- Using the ES6 class syntax

    class Kitten extends React.Component {
        constructor(props) {
            super(props);
        }
        render() {
            return (
                <h1>Hi World</h1>
            );
        }
    }

> This creates an ES6 class "Kitten" which extends the "React.Component" class, so the Kitten class now has access to many useful React features.
> The Kitten class uses "super()" to call the constructor of the parent class.

6. Component composition

Component composition is one of React's powerful features.

> When you work with React, it is important to start thinking about your user interface in terms of components like the App example in the last challenge. You break down your UI into its basic building blocks, and those pieces become the components. This helps to separate the code responsible for the UI from the code responsible for handling your application logic. It can greatly simplify the development and maintenance of complex projects.
> You can render ES6 style class components, JSX elements, stateless functional components within other components, no matter the way of rendering them.

To compose different components together, you include the component name written as a custom HTML tag in the JSX:

    const ChildComponent = () => {
        return (
            <div>
                <p>I am the child</p>
            </div>
        );
    }

    class ParentComponent extends React.Component {
        constructor(props) {
            super(props);
        }
        render() {
            return (
                <div>
                    <h1>I am the parent</h1>
                    <ChildComponent/>
                </div>
            );
        }
    }

7. Pass properties to a stateless functional component

In React, you can pass props (properties) to child components.

    const CurrentDate = (props) => {
        return (
            <div>
                <p>The current date is: {props.date}</p>
            </div>
        )
    }
    class Calendar extends React.Component {
        constructor(props) {
            super(props);
        }
        render() {
            return (
                <div>
                    <h3>What date is it?</h3>
                    <CurrentDate date={Date()}/>
                </div>
            )
        }
    }

CurrentDate is a stateless functional component which is being passed a property 'date' from its parent component. date={Date()} is a custom HTML attribute named 'date' which creates a new JavaScript Date object, then is passed as an "argument" to the <CurrentDate/> component when it's being rendered.

> As the properties you are passing are JavaScript expressions, you can pass in arrays... and operate with them.
> React allows to set default props. You can assign them to a component after its declaration:

    MyComponent.defaultProps = {location: 'San Francisco'}

Now, you have defined a default prop that is set to the string "San Francisco", unless you specify otherwise. The way to override the default props is to explicitly set the prop value for a component:

    <MyComponent location={'Soledad, AtlÃ¡ntico'}>

> React also allows to set proptypes to define the props you expect. It is considered a best practice to set propTypes when you know the type of a prop ahead of time. Doing this will check that props of a given key are present with a given type:

    MyComponent.propTypes = {handleClick: PropTypes.func.isRequired}

This is an example to require the type 'function' for a prop called 'handleClick', and to set the prop 'handleClick' as 'required'.

PropType declaration:
- number | func | string | bool
    Checks if the property is a number | function | string | boolean.
- isRequired
    Sets the property as required.

8. Access properties from an ES6 class component

Anytime you refer to a class component within itself, you use the 'this' keyword:

    class ReturnPassword extends React.Component {
        constructor(props) {
            super(props);
        }
        render() {
            return (
                <div>
                    <p>Your temporary password is: <strong>{this.props.tempPassword}</strong></p>
                </div>
            )
        }
    }
    class ResetPassword extends React.component {
        constructor(props) {
            super(props);
        }
        render() {
            return (
                <div>
                    <ReturnPassword tempPassword={"This_is_my_new_password"}/>
                </div>
            )
        }
    }

This code creates a 'ResetPassword' component which renders a 'ReturnPassword' component with the property 'tempPassword'. The ReturnPassword child component accesses its property with the code: 'this.props.tempPassword'.

9. Create stateful components

* State
It consists of any data you application needs to know about that can change over time. You want your apps to respond to state changes and present an updated UI when necessary.

> State allows you to track important data in you app and render the UI in response to changes in this data. If you data changes, the UI will change.
> If you make a component stateful, no other components are aware of its state because it is completely encapsulated.

You declare a state in a React component by declaring a state property on the component class in its constructor. THis initializes the component with a state when it is created:

    class StatefulComponent extends React.Component {
        constructor(props) {
            super(props);
            this.state = {
                name: "Gasimbo"
            }
        }
        render() {
            return (
                <div>
                    <h1>{this.state.name}</h1>
                </div>
            )
        }
    }

> The state property must be set to a JavaScript object.
> You have to access to the state object throughout the life of your component. You can update it, render it on your UI, and pass it as props to child elements.

* Access the state

You can access a certain property in the state from the render() method with 'this.state.propertyName'. Use curly braces when inside the JSX syntax (after the return statement):

    class MyComponent extends React.Component {
        constructor(props) {
            super(props);
            this.state = {
                name: 'FreeCodeCamp'
            }
        }
        render() {
            const name = this.state.name;
            return (
                <div>
                    <h1>Name: {name}</h1>
                </div>
            )
        }
    }

* Setting the state

You can update a component's state using the method "setState()", passing as key-value pairs the properties you want to update:

    class MyComponent extends React.Component {
        constructor(props) {
            super(props);
            this.state = {
                name: 'Initial State'
            };
            this.handleClick = this.handleClick.bind(this);
        }
        handleClick() {
            this.setState({
                name 'Final State'
            });
        }
        render() {
            return (
                <div>
                    <h1>{this.state.name}</h1>
                    <button onClick={this.handleClick}>Click Me!</button>
                </div>
            )
        }
    }

This code:
    > Creates a component 'MyComponent' with an initial state in its constructor, defines a 'handleClick()' method inside of it, and renders a button and an h1 element.
    > Sets an onClick() handler for the button. It calls the 'handleClick()' method, which updates the state of 'name' property from 'Initial State' to 'Final State'.

> React may batch multiple state updates to improve performance. This means that updating the state with 'setState()' can be asynchrounous.

* Reusing the value of previous state

Sometimes you need to know the value of the previous state when updating it. Because state updates may be asynchrounous, you can't rely on the previous value of "this.state" or "this.props" when calculating the next one.

Instead, you should pass 'setState' a function that allows you to access the most current values of state and props:

    this.setState((state, props) => ({
        counter: state.counter + props.increment;
    }));

You can also pass 'state' as the only argument if you need:
    
    this.setState(state => ({
        counter: state.counter + 1
    }));

10. Define methods inside a component

In addition to setting and updating state, you can also define methods for your component class. A class method tipically need to use the keyword 'this' so it can access properties on the class (such as 'state' and 'props'). There are a few ways to allow your class methods to access 'this'.

* Binding 'this' in the constructor
You can explicitly bind 'this' to the desired method inside the constructor, like so:
    ...
    constructor(props) {
        this.handleClick = this.handleClick.bind(this);
    }
    ...

This way 'this' bounds to the 'handleClick()' method when the component is initialized.

11. Pass parent's state as props to child components

A common pattern to pass state as props is to have a stateful component containing the important state to your app, that then renders child components. These components will have access to some pieces of that state, which are passed as props.

While doing so, pay attention to these important paradigms in React:

> State flows in one direction down the tree of your application components, from the stateful parent component to child components. The child components only receive the state data they need.
> Complex-stateful apps can be broken down to a few or a single stateful component. The rest of the component simply receive state from the parents as props.
> Separating state logic from UI logic is one of React's key principles. When it is used correctly, it makes the design of complex-stateful applications much easier to manage.

* Pass a callback as props

You can pass handler functions, data, or any method that's defined in a React component to a child component. You can access that information using "this.props" in the child component.

* -------------------------------------------------------------------------

12. React's special methods

React components have several special methods that provide opportunities to perform actions at specific points in the lifecycle of a component. These are called 'lifecycle' methods.
These methods allow you to catch components at certain points in time.

- componentWillMount()
    It is called before the render() method when a component is being mounted to the DOM.
    * Tip: It is useful to call console.log() within this method.

    ...
    componentWillMount() {
        console.log("Component added to the DOM!");
    }
    ...

- componentDidMount()
    It is called after a component is mounted to the DOM. Any calls to setState() here will trigger a re-rendering of your component.

    * The best practice with React is to place API calls or any calls to a server in this method. When you call an API in this method, and set your state with the data that the API returns, it will automatically trigger an update once you receive the data.

    ...
        this.state = {
            activeUsers: null
        };
    ...
    componentDidMount() {
        setTimeout(() => {
            this.setState({
                activeUsers: 1273
            });
        }, 2500);
    }
    render() {
        return (
            <div>
                <h1>Active users: {this.state.activeUsers}</h1>
            </div>
        )
    }
    ...

    * The componentDidMount() method is also the best place to attach any event listeners. React provides a synthetic event system that behaves the same regardless the user's browser. However, if you want to attach an event listener to the document or the window, you have to do this directly.

    ...
    componentDidMount() {
        document.addEventListener("keydown", this.methodToCall);
    }
    componentWillUnmount() {
        document.removeEventListener("keydown", this.methodToCall);
    }
    methodToCall() {
        console.log("You called this method!");
    }
    ...

- componentWillUnmount()
    It is called when a component has been removed of the DOM.

- shouldComponentUpdate(nextProps, nextState)
    It is called when child components receive a new state or props, and declares specifically if the components should update or not, depending on a condition.

    ...
    shouldComponentUpdate(nextProps, nextState) {
        console.log("Should component update?");
        if (nextProps.value % 2 === 0) {
            return true;
        }
        return false;
    }
    ...

- componentDidUpdate()
    It is called when a component is updated (receives a new state or props).

-----------------------------------------------------------------------------

13. Styles


* Adding classes
You put CSS classes into JSX elements using the 'className' attribute:

    <div className="yellow-div">Yellow Mellow</div>

* Adding inline styles
You apply inline styles to JSX elements similar to how you do it in HTML (notice the camelCase properties and the quotation in the values):

    <div style={{color: "yellow", fontSize: "16px"}}>Yellow Mellow</div>

You can also create an object full of styles, and then assign the 'style' attribute of the element to the object:

    const myStyles = {
        color: "purple",
        fontSize: "40px",
        border: "2px solid purple"
    }
    class MyComponent extends React.Component {
        render() {
            return (
                <div style={myStyles}>Style Me!</div>
            )
        }
    };


------------------------------------------------------------------------

14. Injecting JavaScript

You can also write JavaScript code directly in your 'render()' method before the return statement, without using curly braces.

    ...
    render() {
        // Insert JavaScript code
        const favouriteString = "Hello World!";
        return (
            <p>{favouriteString}</p>
        )
    }
    ...

15. Conditional rendering

15.1. Simple rendering techniques

You can display different views depending on a condition set in the render() method:

    ...
    render() {
        if (this.state.display) {
            return (
                {/* Some elements */}
            );
        } else {
            return (
                {/* Some other elements */}
            );
        }
    }
    ...

You can also use the operator '&&' to show or not a view:

    ...
    render() {
        return (
            {this.state.display && <h1>Displayed!</h1>}
        );
    }
    ...

You can also use the ternary operator to show or not a view:

    ...
    render() {
        const conTrue = <h1>Condition is true!</h1>
        const conFalse = <h1>Condition is false!<h1>
        return (
            <div>
                {this.state.condition ? conTrue : conFalse}
            </div>
        )
    }
    ...

15.2. Dynamic rendering techniques

You can use props to conditionally render one or another view. You make rendering decisions based on props like so:

    ...
    render() {
        const expression = Math.random() >= 0.5;
        return (
            <div>
                <Results chances={expression}/>
            </div>
        )
    }
    ...

    class Results extends React.Component {
        ...
        render() {
            return (
                this.props.chances
                    ? <h1>You Win!</h1>
                    : <h1>You Lose!</h1>
            );
        }
    }

You can change inline CSS depending on the component's state:

    class GateKeeper extends React.Component {
        constructor(props) {
            super(props)
            this.state = {
                input: ''
            }
            this.handleChange = this.handleChange.bind(this);
        }
        handleChange(event) {
            this.setState({
                input: event.target.value
            })
        }
        render() {
            let inputStyle = {
                border: '1px solid black'
            }
            if (this.state.input.length > 15) {
                inputStyle.border = '3px solid red';
            }
            return (
                <div>
                    <input
                        type="text"
                        style={inputStyle}
                        value={this.state.input}
                        onChange={this.handleChange}/>
                </div>
            )
        }
    }

You can use Array.map() to dynamically render elements. With this method, you have to identify each sibling with a custom 'key' attribute unique to each sibling. This setup is good if you don't know how many elements to render at what given time:

    const frontEndFrameworks = [
        "React", "Angular", "Ember", "Knockout", "Backbone", "Vue"
    ];

    function Frameworks() {
        const renderFrameworks = frontEndFrameworks.map((item) => {
            <li key={item}>{item}</li>
        });
        return (
            <div>
                <h1>Popular Front End JavaScript frameworks</h1>
                <ul>
                    {renderFrameworks}
                </ul>
            </div>
        );
    }

You can use Array.filter() to dinamically filter and render elements:

    class MyComponent extends React.Component {
        constructor(props) {
        super(props);
        this.state = {
            users: [
            {
                username: 'Jeff',
                online: true
            },
            {
                username: 'Alan',
                online: false
            },
            {
                username: 'Mary',
                online: true
            },
            {
                username: 'Jim',
                online: false
            },
            {
                username: 'Sara',
                online: true
            },
            {
                username: 'Laura',
                online: true
            }
            ]
        };
        }
        render() {
            const usersOnline = this.state.users.filter(user => user.online);
            const renderOnline = usersOnline.map((user) => 
                <li key={user.username}>{user.username}</li>
            );
            return (
                <div>
                <h1>Current Online Users:</h1>
                <ul>{renderOnline}</ul>
                </div>
            );
        }
    }

16. Rendering React on the server

Because you can run JavaScript on the server with Node.JS, you can render React components on the server. There are various benefits to this:
    > If you render the initial HTML markup on the server and send this to the client, the initial page load contains all of the page's markup which will improve visibility for your page by search engines, instead of rendering all in the client side.
    > It creates a faster initial load experience, because the rendered HTML is smaller than the JavaScript code of the entire app.
    > React will still be able to recognize and manage your app after the initial load.

You can do this with the 'renderToString()' method provided with the ReactDOMServer object. It takes a React component as the argument.

    class App extends React.Component {
        ...
    }
    ReactDOMServer.renderToString(<App/>);
